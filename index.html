<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Earth Keeper Defense</title>
    <style>
      :root {
        font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #030712;
        color: #e2e8f0;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(circle at top, rgba(59, 130, 246, 0.25), transparent 65%);
      }

      .layout {
        width: min(1200px, 96vw);
        padding: 20px;
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 20px;
      }

      canvas {
        background: #020617;
        border: 2px solid #38bdf8;
        border-radius: 18px;
        box-shadow: 0 25px 60px rgba(15, 23, 42, 0.6);
      }

      .sidebar {
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 18px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      h2 {
        margin: 0;
        font-size: 22px;
        letter-spacing: 0.04em;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
        gap: 12px;
      }

      .stat-card {
        background: rgba(2, 6, 23, 0.7);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 14px;
        padding: 12px;
      }

      .stat-card span {
        display: block;
        font-size: 12px;
        color: #94a3b8;
        letter-spacing: 0.08em;
      }

      .stat-card strong {
        font-size: 24px;
        color: #f8fafc;
      }

      .btn {
        border: none;
        border-radius: 14px;
        padding: 16px;
        background: linear-gradient(120deg, #facc15, #f97316);
        color: #041423;
        font-weight: 700;
        font-size: 18px;
        cursor: pointer;
        transition: transform 0.2s ease;
      }

      .btn.secondary {
        background: linear-gradient(120deg, #22d3ee, #3b82f6);
        color: #041423;
      }

      .btn:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      .btn:hover:not(:disabled) {
        transform: translateY(-3px);
      }

      .instructions {
        font-size: 14px;
        line-height: 1.6;
        color: #cbd5f5;
      }

      ul {
        margin: 0;
        padding-left: 18px;
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <canvas id="game" width="780" height="780"></canvas>
      <aside class="sidebar">
        <h2>Earth Keeper Defense</h2>
        <div class="stats">
          <div class="stat-card">
            <span>기지 HP</span>
            <strong id="base-hp">0</strong>
          </div>
          <div class="stat-card">
            <span>골드</span>
            <strong id="gold">0</strong>
          </div>
          <div class="stat-card">
            <span>남은 시간</span>
            <strong id="timer">120s</strong>
          </div>
          <div class="stat-card">
            <span>퇴치 수</span>
            <strong id="kills">0</strong>
          </div>
        </div>
        <button id="buy-tower" class="btn secondary">골드로 새 타워 배치</button>
        <button id="emergency-power" class="btn secondary">긴급 전력 (7골드)</button>
        <button id="cheat-gold" class="btn secondary">치트: 골드 +200</button>
        <div class="instructions">
          <p>
            노란 전력 구슬이 18개의 외곽 칸을 따라 5초에 한 바퀴 돌며 해당 칸의 능력을 활성화합니다.
            공격형 슬롯은 구슬이 지날 때 1초 동안만 적을 공격할 수 있습니다.
          </p>
          <ul>
            <li>3분 동안 중앙 기지를 지켜내면 승리합니다.</li>
            <li>적 처치 시 2골드 획득, 3골드로 랜덤 타워를 새 슬롯에 배치합니다.</li>
            <li>초기에는 공격 타워 2개와 지원 타워 1개가 자동 배치됩니다.</li>
            <li>같은 종류·레벨의 타워를 드래그해 합치면 Lv업하며 효과가 강화됩니다.</li>
            <li>긴급 전력으로 7골드를 소비하면 3바퀴 동안 전력 구슬이 빠르게 회전합니다.</li>
          </ul>
        </div>
        <button id="start-game" class="btn">게임 시작</button>
      </aside>
    </div>
    <script>
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const ctr = { x: canvas.width / 2, y: canvas.height / 2 };

      // ===== 조절 가능한 스탯 =====
      const CONFIG_SOURCE = {
        enabled: false, // 스프레드시트(또는 JSON) URL을 연결하려면 true로 전환
        url: './config-overrides.json', // 예: 공개된 Google Sheets JSON/CSV → 변환된 엔드포인트
      };

      const LEVEL_MAX = 5;
      const LEVEL_SPEED_MULT = 2.5;

      const CONFIG = {
        base: { maxHp: 400, radius: 80 },
        orb: { slots: 18, radius: 110, revolutionMs: 5000, activeMs: 1200 },
        runtime: { durationMs: 180000, towerCost: 3 },
        emergency: { cost: 7, revolutionMs: 3000, loops: 3 },
        economy: { goldPerKill: 2 },
        waves: { bigWaveIntervalMs: 50000, bigWaveCount: 3 },
        projectiles: { tower: 260, ally: 260, enemy: 260, size: 4 },
        grid: { tile: 28, healAmount: 8, summonCooldown: 4500 },
        enemies: {
          melee: { hp: 18, atk: 4, aps: 2, range: 2, speed: 32, spawn: 4400 },
          ranger: { hp: 10, atk: 3, aps: 1.6, range: 3, speed: 20, spawn: 6400 },
        },
        towers: {
          offense: [
            { name: '공01', dmg: 6, aps: 2.4, range: 10 },
            { name: '공02', dmg: 11, aps: 1.2, range: 8 },
            { name: '공03', dmg: 3, aps: 6, range: 6 },
          ],
          summon: [
            { name: '유닛01', unit: { hp: 40, dmg: 4, aps: 2, range: 4 } },
            { name: '유닛02', unit: { hp: 24, dmg: 3, aps: 1.2, range: 6 } },
          ],
          heal: { name: '회복', heal: 100 },
        },
      };

      async function loadExternalConfig() {
        if (!CONFIG_SOURCE.enabled || !CONFIG_SOURCE.url) return;
        try {
          const res = await fetch(CONFIG_SOURCE.url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const text = await res.text();
          let overrides;
          try {
            overrides = JSON.parse(text);
          } catch (err) {
            console.warn('외부 설정 JSON 파싱 실패', err);
            return;
          }
          mergeDeep(CONFIG, overrides);
          console.info('[CONFIG] 외부 설정을 불러왔습니다.');
        } catch (error) {
          console.warn('[CONFIG] 외부 스프레드시트/JSON을 불러오지 못했습니다.', error);
        }
      }

      function mergeDeep(target, source) {
        if (!source || typeof source !== 'object') return;
        Object.keys(source).forEach((key) => {
          const srcValue = source[key];
          const dstValue = target[key];
          if (Array.isArray(srcValue)) {
            target[key] = srcValue.map((item, idx) => {
              if (typeof item === 'object' && dstValue && typeof dstValue[idx] === 'object') {
                const clone = { ...dstValue[idx] };
                mergeDeep(clone, item);
                return clone;
              }
              return item;
            });
          } else if (srcValue && typeof srcValue === 'object') {
            if (!dstValue || typeof dstValue !== 'object') target[key] = {};
            mergeDeep(target[key], srcValue);
          } else {
            target[key] = srcValue;
          }
        });
      }
      // ============================

      const state = {
        baseHp: CONFIG.base.maxHp,
        gold: 0,
        kills: 0,
        elapsed: 0,
        running: false,
        gameOver: false,
        result: '',
        lastTime: performance.now(),
        orbAngle: 0,
        slots: [],
        towers: [],
        allies: [],
        enemies: [],
        projectiles: [],
        flashes: [],
        damagePopups: [],
        spawnTimers: { melee: 0, ranger: 0 },
        nextBigWave: CONFIG.waves.bigWaveIntervalMs,
        enemySpawnCount: 0,
        dragging: null,
        orbBoostLoops: 0,
        orbBoostProgress: 0,
        orbFastSlotsRemaining: 0,
        paused: false,
        mergeChoice: null,
        baseDamageReductionUntil: 0,
        baseDamageReductionFactor: 1,
      };

      const UI = {
        hp: document.getElementById('base-hp'),
        gold: document.getElementById('gold'),
        timer: document.getElementById('timer'),
        kills: document.getElementById('kills'),
        buyBtn: document.getElementById('buy-tower'),
        emergencyBtn: document.getElementById('emergency-power'),
        cheatBtn: document.getElementById('cheat-gold'),
        startBtn: document.getElementById('start-game'),
      };

      function resetGame() {
        state.baseHp = CONFIG.base.maxHp;
        state.gold = 0;
        state.kills = 0;
        state.elapsed = 0;
        state.gameOver = false;
        state.result = '';
        state.orbAngle = 0;
        state.slots = buildSlots();
        state.towers = [];
        state.allies = [];
        state.enemies = [];
        state.projectiles = [];
        state.flashes = [];
        state.damagePopups = [];
        state.spawnTimers = { melee: 0, ranger: 0 };
        state.nextBigWave = CONFIG.waves.bigWaveIntervalMs;
        state.enemySpawnCount = 0;
        state.dragging = null;
        state.orbBoostLoops = 0;
        state.orbBoostProgress = 0;
        state.orbFastSlotsRemaining = 0;
        state.paused = false;
        state.mergeChoice = null;
        state.baseDamageReductionUntil = 0;
        state.baseDamageReductionFactor = 1;
        placeInitialTowers();
        state.lastTime = performance.now();
        updateHUD();
      }

      function buildSlots() {
        const slots = [];
        for (let i = 0; i < CONFIG.orb.slots; i += 1) {
          const angle = (Math.PI * 2 * i) / CONFIG.orb.slots - Math.PI / 2;
          slots.push({ angle, tower: null, lastActivated: 0 });
        }
        return slots;
      }

      function placeInitialTowers() {
        const pool = [...state.slots];
        const claim = (def) => {
          if (!pool.length || !def) return;
          const slot = pool.splice(Math.floor(Math.random() * pool.length), 1)[0];
          slot.tower = createTower(def, slot);
          registerTower(slot.tower);
        };
        claim(randomOf(CONFIG.towers.offense));
        claim(randomOf(CONFIG.towers.offense));
        claim(randomOf(CONFIG.towers.summon));
        claim(CONFIG.towers.heal);
      }

      function randomOf(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function randomTowerDefByType(type) {
        if (type === 'offense') return randomOf(CONFIG.towers.offense);
        if (type === 'summon') return randomOf(CONFIG.towers.summon);
        if (type === 'heal') return CONFIG.towers.heal;
        return null;
      }

      function randomTowerDefAny() {
        const pool = [...CONFIG.towers.offense, ...CONFIG.towers.summon];
        if (CONFIG.towers.heal) pool.push(CONFIG.towers.heal);
        return randomOf(pool.filter(Boolean));
      }

      function towerTypeFromDef(def) {
        if (!def) return 'offense';
        if (def.heal) return 'heal';
        if (def.unit) return 'summon';
        return 'offense';
      }

      function canMerge(sourceSlot, targetSlot) {
        if (!sourceSlot || !targetSlot || sourceSlot === targetSlot) return false;
        const a = sourceSlot.tower;
        const b = targetSlot.tower;
        if (!a || !b) return false;
        if (a.type !== b.type) return false;
        if (a.level !== b.level) return false;
        if (a.level >= LEVEL_MAX) return false;
        return true;
      }

      function attemptMerge(sourceSlot, targetSlot) {
        if (!canMerge(sourceSlot, targetSlot) || state.mergeChoice) return false;
        const newLevel = Math.min(LEVEL_MAX, targetSlot.tower.level + 1);
        const newDef = randomTowerDefAny();
        unregisterTower(sourceSlot.tower);
        unregisterTower(targetSlot.tower);
        sourceSlot.tower = null;
        targetSlot.tower = null;
        const resultType = towerTypeFromDef(newDef);
        if (resultType === 'offense' && newLevel === 3) {
          startOffenseChoice(targetSlot, newLevel, newDef);
          return true;
        }
        if (resultType === 'heal' && newLevel === 3) {
          startHealChoice(targetSlot, newLevel, newDef);
          return true;
        }
        if (resultType === 'summon' && newLevel === 3) {
          startSummonChoice(targetSlot, newLevel, newDef);
          return true;
        }
        const upgraded = createTower(newDef, targetSlot, newLevel);
        targetSlot.tower = upgraded;
        registerTower(upgraded);
        return true;
      }

      function createTower(def, slot, level = 1) {
        if (!def) return null;
        if (def.heal) {
          return {
            slot,
            type: 'heal',
            heal: def.heal,
            level,
            baseDef: def,
          };
        }
        if (def.unit) {
          return {
            slot,
            type: 'summon',
            unit: { ...def.unit },
            cooldown: 0,
            level,
            baseDef: def,
            summonVariant: 'standard',
            specialShape: null,
          };
        }
        return {
          slot,
          type: 'offense',
          damage: def.dmg,
          aps: def.aps,
          rangePx: def.range * CONFIG.grid.tile,
          activeUntil: 0,
          lastAttack: 0,
          level,
          baseDef: def,
          shotsThisActivation: 0,
        };
      }

      function registerTower(tower) {
        if (tower) state.towers.push(tower);
      }

      function unregisterTower(tower) {
        const idx = state.towers.indexOf(tower);
        if (idx >= 0) state.towers.splice(idx, 1);
      }

      function slotPosition(slot) {
        return {
          x: ctr.x + Math.cos(slot.angle) * CONFIG.orb.radius,
          y: ctr.y + Math.sin(slot.angle) * CONFIG.orb.radius,
        };
      }

      function slotHitTest(x, y) {
        for (let i = 0; i < state.slots.length; i += 1) {
          const slot = state.slots[i];
          const pos = slotPosition(slot);
          if (Math.abs(x - pos.x) <= 24 && Math.abs(y - pos.y) <= 24) return slot;
        }
        return null;
      }

      function canvasPoint(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: ((evt.clientX - rect.left) / rect.width) * canvas.width,
          y: ((evt.clientY - rect.top) / rect.height) * canvas.height,
        };
      }

      function handlePointerDown(evt) {
        if (!state.running) return;
        if (typeof evt.button === 'number' && evt.button !== 0) return;
        const pos = canvasPoint(evt);
        if (state.mergeChoice) {
          evt.preventDefault();
          handleMergeChoiceSelection(pos);
          return;
        }
        if (state.paused) return;
        const slot = slotHitTest(pos.x, pos.y);
        if (!slot || !slot.tower) return;
        evt.preventDefault();
        state.dragging = {
          slot,
          tower: slot.tower,
          pointerId: evt.pointerId,
          x: pos.x,
          y: pos.y,
        };
        if (canvas.setPointerCapture) {
          try {
            canvas.setPointerCapture(evt.pointerId);
          } catch (_) {}
        }
      }

      function handlePointerMove(evt) {
        if (state.mergeChoice || state.paused) return;
        if (!state.dragging || state.dragging.pointerId !== evt.pointerId) return;
        const pos = canvasPoint(evt);
        state.dragging.x = pos.x;
        state.dragging.y = pos.y;
      }

      function handlePointerUp(evt) {
        if (!state.dragging || state.dragging.pointerId !== evt.pointerId) return;
        const pos = canvasPoint(evt);
        const target = slotHitTest(pos.x, pos.y);
        if (target) attemptMerge(state.dragging.slot, target);
        state.dragging = null;
        if (canvas.releasePointerCapture) {
          try {
            canvas.releasePointerCapture(evt.pointerId);
          } catch (_) {}
        }
      }

      function activateSlot(slot) {
        const tower = slot.tower;
        if (!tower) return;
        if (tower.type === 'offense') {
          tower.activeUntil = performance.now() + CONFIG.orb.activeMs;
          tower.lastAttack = 0;
          tower.shotsThisActivation = 0;
        } else if (tower.type === 'summon') {
          if (tower.cooldown < performance.now()) {
            spawnAlly(tower);
            tower.cooldown = performance.now() + CONFIG.grid.summonCooldown;
          }
        } else if (tower.type === 'heal') {
          state.baseHp = Math.min(CONFIG.base.maxHp, state.baseHp + getHealAmount(tower));
          if (tower.healVariant === 'speed-chain') {
            state.orbFastSlotsRemaining += 6;
          } else if (tower.healVariant === 'shield') {
            state.baseHp = Math.min(CONFIG.base.maxHp, state.baseHp + 50);
            state.baseDamageReductionUntil = performance.now() + 2000;
            state.baseDamageReductionFactor = 0.4;
          }
        }
      }

      function spawnAlly(tower) {
        const unit = tower.unit;
        const pos = slotPosition(tower.slot);
        const stats = getSummonStats(tower);
        const variant = tower.summonVariant || 'standard';
        const baseSpeed = CONFIG.enemies.melee.speed;
        for (let i = 0; i < stats.count; i += 1) {
          const spread = stats.count > 1 ? 18 : 0;
          const angleOffset = stats.count > 1 ? (i - (stats.count - 1) / 2) * 0.35 : 0;
          const offsetX = spread ? Math.cos(tower.slot.angle + angleOffset) * spread : 0;
          const offsetY = spread ? Math.sin(tower.slot.angle + angleOffset) * spread : 0;
          let hp = unit.hp;
          let damage = unit.dmg;
          let speed = baseSpeed;
          let shape = 'circle';
          let color = '#4ade80';
          let tauntRadius = 0;
          let fanCone = null;
          if (variant === 'tank') {
            hp *= 2;
            damage *= 0.5;
            shape = 'rectangle';
            color = '#fb923c';
            tauntRadius = 300;
          } else if (variant === 'fan') {
            damage *= 0.5;
            speed = baseSpeed / 3;
            shape = 'fan';
            color = '#60a5fa';
            fanCone = { radius: 75, angle: 120 };
          }
          state.allies.push({
            x: pos.x + offsetX,
            y: pos.y + offsetY,
            hp,
            damage,
            aps: stats.aps,
            rangePx: unit.range * CONFIG.grid.tile,
            speed,
            lastAttack: 0,
            expireAt: performance.now() + 10000,
            variant,
            shape,
            color,
            tauntRadius,
            fanCone,
          });
        }
      }

      function levelMultiplier(level) {
        if (level <= 1) return 1;
        return Math.pow(LEVEL_SPEED_MULT, level - 1);
      }

      function effectiveLevel(tower) {
        if (!tower) return 1;
        return tower.level + getAuraBonus(tower);
      }

      function getAuraBonus(tower) {
        if (!tower || !tower.slot) return 0;
        let bonus = 0;
        state.towers.forEach((other) => {
          if (!other || other === tower || other.variant !== 'mentor' || !other.slot) return;
          const dist = distance(slotPosition(other.slot), slotPosition(tower.slot));
          if (dist <= 70) bonus += 1;
        });
        return bonus;
      }

      function getOffenseStats(tower) {
        const level = effectiveLevel(tower);
        return {
          rangePx: tower.rangePx,
          aps: tower.aps * levelMultiplier(level),
          damage: tower.damage,
        };
      }

      function getHealAmount(tower) {
        const level = effectiveLevel(tower);
        return (tower.heal || CONFIG.grid.healAmount) * levelMultiplier(level);
      }

      function getSummonStats(tower) {
        const level = effectiveLevel(tower);
        return {
          count: level > 1 ? 2 : 1,
          aps: tower.unit.aps * levelMultiplier(level),
        };
      }

      function startOffenseChoice(slot, level, baseDef) {
        const cards = buildOffenseChoiceCards(baseDef);
        state.mergeChoice = {
          slot,
          level,
          baseDef,
          cards,
          cardBounds: [],
          type: 'offense',
        };
        state.paused = true;
      }

      function startHealChoice(slot, level, baseDef) {
        const cards = buildHealChoiceCards();
        state.mergeChoice = {
          slot,
          level,
          baseDef,
          cards,
          cardBounds: [],
          type: 'heal',
        };
        state.paused = true;
      }

      function buildOffenseChoiceCards(baseDef) {
        const baseDamage = baseDef?.dmg || 6;
        return [
          {
            key: 'knockback',
            title: '넉백 타워',
            desc: `공격력 70% (${Math.round(baseDamage * 0.7)}) 데미지\n명중 시 적을 크게 밀쳐냅니다.`,
            damageMultiplier: 0.7,
            variant: 'knockback',
            shape: 'hex',
          },
          {
            key: 'explosive',
            title: '폭발형 타워',
            desc: `공격력 60% (${Math.round(baseDamage * 0.6)}) 데미지\n100px 범위 폭발로 광역 피해.`,
            damageMultiplier: 0.6,
            variant: 'explosive',
            shape: 'triangle',
            radius: 100,
          },
          {
            key: 'standard',
            title: '일반 공격형',
            desc: `공격력 120% (${Math.round(baseDamage * 1.2)}) 데미지\n집중 사격으로 높은 피해.`,
            damageMultiplier: 1.2,
            variant: 'standard',
            shape: 'circle',
          },
        ];
      }

      function finalizeOffenseChoice(option) {
        if (!state.mergeChoice) return;
        const slot = state.mergeChoice.slot;
        const level = state.mergeChoice.level;
        const baseDef = state.mergeChoice.baseDef || randomTowerDefByType('offense');
        const tower = createTower(baseDef, slot, level);
        slot.tower = tower;
        const baseDamage = baseDef?.dmg ?? tower.damage;
        tower.damage = baseDamage * option.damageMultiplier * (option.variant === 'explosive' ? 3 : 1);
        tower.specialShape = option.shape;
        tower.variant = option.variant;
        if (option.variant === 'explosive') {
          tower.explosionRadius = option.radius || 100;
        } else if (option.variant === 'knockback') {
          tower.knockback = true;
        }
        registerTower(tower);
        state.mergeChoice = null;
        state.paused = false;
      }

      function buildHealChoiceCards() {
        return [
          {
            key: 'speed-chain',
            title: '전력 가속',
            desc: '발동 후 다음 6칸 동안\n전력 구슬 속도 2배',
            variant: 'speed-chain',
            shape: 'diamond',
          },
          {
            key: 'sanctuary',
            title: '보호 장막',
            desc: '즉시 HP 50 회복 후\n2초간 본체 피해 60% 감소',
            variant: 'shield',
            shape: 'circle',
          },
          {
            key: 'mentor',
            title: '격려의 제단',
            desc: '근접한 타워들의 실질 레벨 +1\n(합성 레벨에는 미반영)',
            variant: 'mentor',
            shape: 'triangle',
          },
        ];
      }

      function finalizeHealChoice(option) {
        if (!state.mergeChoice) return;
        const slot = state.mergeChoice.slot;
        const level = state.mergeChoice.level;
        const baseDef = state.mergeChoice.baseDef || CONFIG.towers.heal;
        const tower = createTower(baseDef, slot, level);
        slot.tower = tower;
        tower.healVariant = option.variant;
        if (option.shape) tower.specialShape = option.shape;
        if (option.variant === 'mentor') {
          tower.variant = 'mentor';
        }
        registerTower(tower);
        state.mergeChoice = null;
        state.paused = false;
      }

      function startSummonChoice(slot, level, baseDef) {
        const cards = buildSummonChoiceCards(baseDef);
        state.mergeChoice = {
          slot,
          level,
          baseDef,
          cards,
          cardBounds: [],
          type: 'summon',
        };
        state.paused = true;
      }

      function buildSummonChoiceCards(baseDef) {
        const unit = baseDef?.unit || { hp: 40, dmg: 4 };
        return [
          {
            key: 'standard',
            title: '일반 소환',
            desc: '기존 능력치의 공격 유닛을 소환합니다.',
            variant: 'standard',
            shape: 'circle',
          },
          {
            key: 'tank',
            title: '방패병',
            desc: '긴 막대기형 유닛.\nHP x2, ATK 50%, 300px 도발.',
            variant: 'tank',
            shape: 'rectangle',
          },
          {
            key: 'fan',
            title: '서리 부채',
            desc: '부채꼴 광역 공격.\n이동속도 1/3, ATK 50%.',
            variant: 'fan',
            shape: 'fan',
          },
        ];
      }

      function finalizeSummonChoice(option) {
        if (!state.mergeChoice) return;
        const slot = state.mergeChoice.slot;
        const level = state.mergeChoice.level;
        const baseDef = state.mergeChoice.baseDef;
        const tower = createTower(baseDef, slot, level);
        slot.tower = tower;
        tower.summonVariant = option.variant;
        tower.specialShape = option.shape;
        registerTower(tower);
        state.mergeChoice = null;
        state.paused = false;
      }

      function spawnEnemy(type) {
        const def = CONFIG.enemies[type];
        if (!def) return;
        state.enemySpawnCount += 1;
        const timeScale = Math.pow(1.1, Math.floor(state.elapsed / 10000));
        const hpScale = 1 + state.enemySpawnCount * 0.05;
        const hp = def.hp * timeScale * hpScale;
        const angle = Math.random() * Math.PI * 2;
        const radius = CONFIG.orb.radius + 260;
        state.enemies.push({
          type,
          x: ctr.x + Math.cos(angle) * radius,
          y: ctr.y + Math.sin(angle) * radius,
          hp,
          maxHp: hp,
          attack: def.atk * timeScale,
          rangePx: def.range * CONFIG.grid.tile,
          speed: def.speed,
          baseSpeed: def.speed,
          aps: def.aps,
          lastAttack: 0,
          focus: null,
          knockbackLockUntil: 0,
          slowUntil: 0,
          slowFactor: 1,
        });
      }

      function updatePowerOrb(delta) {
        const fastBoost = state.orbFastSlotsRemaining > 0 && state.orbBoostLoops <= 0;
        const rev =
          state.orbBoostLoops > 0
            ? CONFIG.emergency.revolutionMs
            : fastBoost
            ? CONFIG.orb.revolutionMs / 2
            : CONFIG.orb.revolutionMs;
        const deltaAngle = ((Math.PI * 2) / rev) * delta;
        state.orbAngle = (state.orbAngle + deltaAngle) % (Math.PI * 2);
        if (state.orbBoostLoops > 0) {
          state.orbBoostProgress += deltaAngle;
          while (state.orbBoostProgress >= Math.PI * 2) {
            state.orbBoostProgress -= Math.PI * 2;
            state.orbBoostLoops -= 1;
            if (state.orbBoostLoops <= 0) {
              state.orbBoostLoops = 0;
              state.orbBoostProgress = 0;
              break;
            }
          }
        } else {
          state.orbBoostProgress = 0;
        }
        state.slots.forEach((slot) => {
          const diff = normalizeAngle(state.orbAngle - slot.angle);
          if (Math.abs(diff) < 0.12 && performance.now() - slot.lastActivated > 450) {
            activateSlot(slot);
            slot.lastActivated = performance.now();
            if (state.orbFastSlotsRemaining > 0) {
              state.orbFastSlotsRemaining = Math.max(0, state.orbFastSlotsRemaining - 1);
            }
          }
        });
      }

      function normalizeAngle(angle) {
        let a = angle;
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
      }

      function updateTowers(delta) {
        const now = performance.now();
        state.towers.forEach((tower) => {
          if (tower.type !== 'offense') return;
          if (now > tower.activeUntil) return;
          const origin = slotPosition(tower.slot);
          const stats = getOffenseStats(tower);
          const limitShot = tower.variant === 'explosive';
          if (limitShot && tower.shotsThisActivation >= 1) return;
          if (now - tower.lastAttack >= 1000 / stats.aps) {
            const target = findEnemyFromBase(stats.rangePx);
            if (target) {
              const meta =
                tower.variant === 'explosive'
                  ? { type: 'explosive', radius: tower.explosionRadius || 100 }
                  : null;
              fireProjectile(
                origin,
                target,
                stats.damage,
                '#38bdf8',
                CONFIG.projectiles.tower,
                'tower',
                tower,
                meta
              );
              tower.lastAttack = now;
              tower.shotsThisActivation = (tower.shotsThisActivation || 0) + 1;
            }
          }
        });
      }

      function updateAllies(delta) {
        const now = performance.now();
        for (let i = state.allies.length - 1; i >= 0; i -= 1) {
          const ally = state.allies[i];
          if (ally.expireAt && now > ally.expireAt) {
            state.allies.splice(i, 1);
            continue;
          }
          const chase = findNearestEnemy(ally, Infinity);
          if (chase) moveTowards(ally, chase, ally.speed, delta);
          if (now - ally.lastAttack >= 1000 / ally.aps) {
            const target = findNearestEnemy(ally, ally.rangePx);
            if (target) {
              if (ally.variant === 'fan' && ally.fanCone) {
                fanAttack(ally, target);
              } else {
                fireProjectile(
                  { x: ally.x, y: ally.y },
                  target,
                  ally.damage,
                  ally.color || '#4ade80',
                  CONFIG.projectiles.ally,
                  'ally',
                  ally
                );
              }
              ally.lastAttack = now;
            }
          }
        }
      }

      function handleMergeChoiceSelection(pos) {
        if (!state.mergeChoice || !state.mergeChoice.cardBounds) return false;
        for (const card of state.mergeChoice.cardBounds) {
          if (
            pos.x >= card.x &&
            pos.x <= card.x + card.width &&
            pos.y >= card.y &&
            pos.y <= card.y + card.height
          ) {
            if (state.mergeChoice.type === 'heal') finalizeHealChoice(card.option);
            else if (state.mergeChoice.type === 'summon') finalizeSummonChoice(card.option);
            else finalizeOffenseChoice(card.option);
            return true;
          }
        }
        return false;
      }

      function updateEnemies(delta) {
        const now = performance.now();
        state.enemies.forEach((enemy) => {
          const target = chooseEnemyTarget(enemy);
          const moveSpeed =
            enemy.slowUntil && now < enemy.slowUntil
              ? enemy.baseSpeed * (enemy.slowFactor || 1 / 3)
              : enemy.baseSpeed;
          moveTowards(enemy, target === 'base' ? ctr : target, moveSpeed, delta);
          if (enemy.slowUntil && now >= enemy.slowUntil) {
            enemy.slowUntil = 0;
            enemy.slowFactor = 1;
          }
          if (now - enemy.lastAttack >= 1000 / enemy.aps) {
            if (enemy.rangePx <= CONFIG.grid.tile * 2) {
              applyDamage(target, enemy.attack);
            } else {
              fireProjectile(
                { x: enemy.x, y: enemy.y },
                target,
                enemy.attack,
                '#fb7185',
                CONFIG.projectiles.enemy,
                'enemy',
                enemy
              );
            }
            enemy.lastAttack = now;
          }
        });
      }

      function chooseEnemyTarget(enemy) {
        if (enemy.focus && (!state.allies.includes(enemy.focus) || enemy.focus.hp <= 0)) {
          enemy.focus = null;
        }
        const taunt = findTauntTarget(enemy);
        if (taunt) {
          enemy.focus = taunt;
          return taunt;
        }
        if (enemy.focus) return enemy.focus;
        const ally = findNearestAlly(enemy, Infinity);
        const distToBase = distance(enemy, ctr);
        if (ally) {
          const distToAlly = distance(enemy, ally);
          if (distToAlly <= distToBase) {
            enemy.focus = ally;
            return ally;
          }
        }
        return 'base';
      }

      function findNearestEnemy(origin, rangePx) {
        return findClosest(state.enemies, origin, rangePx);
      }

      function findEnemyFromBase(rangePx) {
        return findClosest(state.enemies, ctr, rangePx);
      }

      function findNearestAlly(origin, rangePx) {
        return findClosest(state.allies, origin, rangePx);
      }

      function findTauntTarget(enemy) {
        for (const ally of state.allies) {
          if (ally.tauntRadius && distance(ally, enemy) <= ally.tauntRadius) return ally;
        }
        return null;
      }

      function findClosest(collection, origin, rangePx) {
        let best = null;
        let bestDist = Infinity;
        collection.forEach((unit) => {
          const dist = distance(origin, unit);
          if (dist <= rangePx && dist < bestDist) {
            best = unit;
            bestDist = dist;
          }
        });
        return best;
      }

      function moveTowards(obj, target, speed, delta) {
        const dest = target === 'base' ? ctr : target;
        const dx = dest.x - obj.x;
        const dy = dest.y - obj.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 1) return;
        const step = Math.min(dist, speed * (delta / 1000));
        obj.x += (dx / dist) * step;
        obj.y += (dy / dist) * step;
      }

      function fireProjectile(origin, target, damage, color, speed, ownerType, ownerRef = null, meta = null) {
        state.projectiles.push({
          x: origin.x,
          y: origin.y,
          target,
          damage,
          color,
          speed,
          ownerType,
          ownerRef,
          meta,
        });
        state.flashes.push({ x: origin.x, y: origin.y, color, created: performance.now() });
      }

      function showAoeRing(x, y, radius, color = '#f87171', duration = 220) {
        state.flashes.push({ x, y, color, radius, duration, created: performance.now() });
      }

      function showConeFlash(x, y, radius, angle, spread, color = 'rgba(59,130,246,0.5)', duration = 200) {
        state.flashes.push({
          type: 'cone',
          x,
          y,
          radius,
          angle,
          spread,
          color,
          duration,
          created: performance.now(),
        });
      }

      function addDamagePopup(x, y, amount, color, size = 14) {
        state.damagePopups.push({
          x,
          y,
          amount,
          color,
          size,
          created: performance.now(),
          duration: 200,
        });
      }

      function addHitFlash(entity) {
        state.flashes.push({
          type: 'hit',
          x: entity.x,
          y: entity.y,
          size: 18,
          color: 'rgba(248,113,113,0.4)',
          duration: 140,
          created: performance.now(),
        });
      }

      function updateProjectiles(delta) {
        const isActiveTarget = (target) => {
          if (target === 'base') return true;
          return state.enemies.includes(target) || state.allies.includes(target);
        };
        for (let i = state.projectiles.length - 1; i >= 0; i -= 1) {
          const proj = state.projectiles[i];
          if (!proj.target || !isActiveTarget(proj.target)) {
            state.projectiles.splice(i, 1);
            continue;
          }
          const point = proj.target === 'base' ? ctr : proj.target;
          const dx = point.x - proj.x;
          const dy = point.y - proj.y;
          const dist = Math.hypot(dx, dy);
          const step = proj.speed * (delta / 1000);
          if (dist <= step) {
            applyDamage(proj.target, proj.damage, proj.ownerType, proj.ownerRef, proj.meta, point);
            state.projectiles.splice(i, 1);
          } else {
            proj.x += (dx / dist) * step;
            proj.y += (dy / dist) * step;
          }
        }
      }

      function applyDamage(target, damage, ownerType = null, ownerRef = null, meta = null, point = null) {
        if (ownerType === 'tower' && ownerRef?.variant === 'explosive' && meta?.type === 'explosive' && point) {
          showAoeRing(point.x, point.y, meta.radius);
          for (let i = state.enemies.length - 1; i >= 0; i -= 1) {
            const enemy = state.enemies[i];
            if (distance(enemy, point) <= meta.radius) {
              damageEnemy(enemy, damage, ownerType, ownerRef);
            }
          }
          return;
        }
        if (target === 'base') {
          const now = performance.now();
          if (now > state.baseDamageReductionUntil) {
            state.baseDamageReductionFactor = 1;
          }
          const factor = now < state.baseDamageReductionUntil ? state.baseDamageReductionFactor : 1;
          const actual = damage * factor;
          state.baseHp -= actual;
          addDamagePopup(ctr.x, ctr.y, actual, '#ff4d4f', 20);
          return;
        }
        const enemyIdx = state.enemies.indexOf(target);
        if (enemyIdx >= 0) {
          const enemy = state.enemies[enemyIdx];
          damageEnemy(enemy, damage, ownerType, ownerRef);
          if (ownerType === 'tower' && ownerRef?.variant === 'knockback' && enemy.hp > 0) {
            applyKnockback(enemy);
          }
          return;
        }
        const allyIdx = state.allies.indexOf(target);
        if (allyIdx >= 0) {
          state.allies[allyIdx].hp -= damage;
          addDamagePopup(state.allies[allyIdx].x, state.allies[allyIdx].y - 12, damage, '#ff4d4f');
          addHitFlash(state.allies[allyIdx]);
          if (state.allies[allyIdx].hp <= 0) state.allies.splice(allyIdx, 1);
        }
      }

      function damageEnemy(enemy, damage, ownerType, ownerRef) {
        if (!enemy) return;
        enemy.hp -= damage;
        addDamagePopup(enemy.x, enemy.y - 16, damage, '#f8fafc');
        addHitFlash(enemy);
        if (ownerType === 'ally' && ownerRef) enemy.focus = ownerRef;
        if (enemy.hp <= 0) {
          const idx = state.enemies.indexOf(enemy);
          if (idx >= 0) state.enemies.splice(idx, 1);
          state.gold += CONFIG.economy.goldPerKill ?? 1;
          state.kills += 1;
        }
      }

      function applyKnockback(enemy) {
        const now = performance.now();
        if (enemy.knockbackLockUntil && now < enemy.knockbackLockUntil) return;
        const dx = enemy.x - ctr.x;
        const dy = enemy.y - ctr.y;
        const dist = Math.hypot(dx, dy);
        if (dist === 0) return;
        const push = 46;
        enemy.x += (dx / dist) * push;
        enemy.y += (dy / dist) * push;
        enemy.knockbackLockUntil = now + 1000;
      }

      function fanAttack(ally, target) {
        const cone = ally.fanCone;
        if (!cone) return;
        const dir = Math.atan2(target.y - ally.y, target.x - ally.x);
        const half = ((cone.angle || 120) * Math.PI) / 360;
        showConeFlash(ally.x, ally.y, cone.radius || 75, dir, cone.angle || 120, 'rgba(59,130,246,0.45)');
        state.enemies.forEach((enemy) => {
          const dist = distance(ally, enemy);
          if (dist > (cone.radius || 75)) return;
          const ang = Math.atan2(enemy.y - ally.y, enemy.x - ally.x);
          const diff = Math.abs(normalizeAngle(dir - ang));
          if (diff <= half) {
            damageEnemy(enemy, ally.damage, 'ally', ally);
            enemy.slowUntil = performance.now() + 1000;
            enemy.slowFactor = 1 / 3;
          }
        });
      }

      function distance(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }

      function updateSpawns(delta) {
        state.spawnTimers.melee += delta;
        state.spawnTimers.ranger += delta;
        if (state.spawnTimers.melee >= CONFIG.enemies.melee.spawn) {
          spawnEnemy('melee');
          state.spawnTimers.melee = 0;
        }
        if (state.spawnTimers.ranger >= CONFIG.enemies.ranger.spawn) {
          spawnEnemy('ranger');
          state.spawnTimers.ranger = 0;
        }
        if (state.elapsed >= state.nextBigWave) {
          for (let i = 0; i < CONFIG.waves.bigWaveCount; i += 1) {
            spawnEnemy('melee');
            spawnEnemy('ranger');
          }
          state.nextBigWave += CONFIG.waves.bigWaveIntervalMs;
        }
      }

      function updateHUD() {
        UI.hp.textContent = Math.max(0, Math.ceil(state.baseHp));
        UI.gold.textContent = state.gold;
        UI.kills.textContent = state.kills;
        const remain = Math.max(0, Math.ceil((CONFIG.runtime.durationMs - state.elapsed) / 1000));
        UI.timer.textContent = `${remain}s`;
       UI.buyBtn.disabled =
         !state.running || state.gameOver || state.gold < CONFIG.runtime.towerCost || state.paused;
       UI.buyBtn.textContent = `${CONFIG.runtime.towerCost} 골드로 새 타워 배치`;
       UI.emergencyBtn.disabled =
         !state.running || state.gameOver || state.gold < CONFIG.emergency.cost || state.paused;
       UI.emergencyBtn.textContent = `긴급 전력 (${CONFIG.emergency.cost}골드)`;
       UI.cheatBtn.disabled = !state.running || state.gameOver;
     }

      function gameLoop() {
        const now = performance.now();
        const delta = now - state.lastTime;
        state.lastTime = now;
        if (state.running && !state.gameOver && !state.paused) {
          state.elapsed += delta;
          updateSpawns(delta);
          updatePowerOrb(delta);
          updateTowers(delta);
          updateAllies(delta);
          updateEnemies(delta);
          updateProjectiles(delta);
          if (state.baseHp <= 0) {
            state.baseHp = 0;
            state.gameOver = true;
            state.result = '기지가 파괴되었습니다...';
          } else if (state.elapsed >= CONFIG.runtime.durationMs) {
            state.gameOver = true;
            state.result = '3분간 방어 성공! 승리!';
          }
        }
        updateHUD();
        draw();
        requestAnimationFrame(gameLoop);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBase();
        drawSlots();
        drawPowerOrb();
        drawEnemies();
        drawAllies();
        drawFlashes();
        drawProjectiles();
        drawDamagePopups();
        drawDraggingTower();
        if (state.mergeChoice) drawMergeChoiceOverlay();
        if (state.gameOver) drawOverlay();
      }

      function drawBase() {
        ctx.beginPath();
        ctx.arc(ctr.x, ctr.y, CONFIG.base.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#1d2453';
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#94a3b8';
        ctx.stroke();
        const ratio = state.baseHp / CONFIG.base.maxHp;
        ctx.beginPath();
        ctx.arc(ctr.x, ctr.y, CONFIG.base.radius + 8, -Math.PI / 2, -Math.PI / 2 + ratio * Math.PI * 2);
        ctx.strokeStyle = '#f87171';
        ctx.lineWidth = 6;
        ctx.stroke();
      }

      function towerLabel(tower) {
        if (!tower) return '';
        if (tower.type === 'offense') return 'ATK';
        if (tower.type === 'summon') return 'SMN';
        return 'HEAL';
      }

      function towerColor(tower) {
        if (!tower) return 'rgba(148,163,184,0.2)';
        if (tower.type === 'offense') return '#38bdf8';
        if (tower.type === 'summon') return '#a78bfa';
        return '#facc15';
      }

      function drawTowerLabels(tower) {
        if (!tower) return;
        ctx.fillStyle = '#020617';
        ctx.font = '11px Pretendard';
        ctx.textAlign = 'center';
        ctx.fillText(towerLabel(tower), 0, -2);
        ctx.font = '13px Pretendard';
        ctx.fillText(`Lv${tower.level}`, 0, 18);
      }

      function drawSlots() {
        state.slots.forEach((slot, idx) => {
          const pos = slotPosition(slot);
          const highlight = state.dragging && canMerge(state.dragging.slot, slot);
          ctx.save();
          ctx.translate(pos.x, pos.y);
          ctx.rotate(slot.angle + Math.PI / 2);
          ctx.strokeStyle = highlight ? '#fde047' : 'rgba(148,163,184,0.4)';
          ctx.lineWidth = highlight ? 3 : 1;
          ctx.strokeRect(-22, -22, 44, 44);
          ctx.lineWidth = 1;
          ctx.fillStyle = 'rgba(148,163,184,0.2)';
          ctx.font = '12px Pretendard';
          ctx.textAlign = 'center';
          ctx.fillText(String(idx + 1).padStart(2, '0'), 0, -26);
          if (slot.tower) {
            if (state.dragging && slot === state.dragging.slot) {
              ctx.setLineDash([4, 3]);
              ctx.strokeStyle = '#fde047';
              ctx.strokeRect(-20, -20, 40, 40);
              ctx.setLineDash([]);
            } else {
              ctx.fillStyle = towerColor(slot.tower);
              ctx.fillRect(-20, -20, 40, 40);
              drawTowerVariantOverlay(slot.tower);
              drawTowerLabels(slot.tower);
            }
          }
          ctx.restore();
        });
      }

      function drawTowerVariantOverlay(tower) {
        ctx.save();
        if (tower.specialShape) {
          ctx.globalAlpha = 0.5;
          ctx.fillStyle = '#000000';
          drawShapePath(tower.specialShape, 16);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        if (tower.variant === 'mentor') {
          ctx.fillStyle = 'rgba(250,204,21,0.3)';
          ctx.fillRect(-20, -20, 40, 40);
          ctx.strokeStyle = 'rgba(250,204,21,0.65)';
          ctx.lineWidth = 2;
          ctx.strokeRect(-22, -22, 44, 44);
          ctx.lineWidth = 1;
        }
        if (getAuraBonus(tower) > 0) {
          ctx.fillStyle = 'rgba(250,204,21,0.25)';
          ctx.fillRect(-20, -20, 40, 40);
        }
        ctx.restore();
      }

      function drawShapePath(shape, radius = 16) {
        ctx.beginPath();
        if (shape === 'hex') {
          for (let i = 0; i < 6; i += 1) {
            const angle = (Math.PI / 3) * i - Math.PI / 2;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
        } else if (shape === 'triangle') {
          ctx.moveTo(0, -radius);
          ctx.lineTo(radius * 0.9, radius * 0.9);
          ctx.lineTo(-radius * 0.9, radius * 0.9);
          ctx.closePath();
        } else if (shape === 'diamond') {
          ctx.moveTo(0, -radius);
          ctx.lineTo(radius, 0);
          ctx.lineTo(0, radius);
          ctx.lineTo(-radius, 0);
          ctx.closePath();
        } else if (shape === 'square') {
          ctx.rect(-radius, -radius, radius * 2, radius * 2);
        } else if (shape === 'rectangle') {
          ctx.rect(-radius * 1.8, -radius * 0.6, radius * 3.6, radius * 1.2);
        } else if (shape === 'fan') {
          const fanAngle = (120 * Math.PI) / 180;
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, radius, -fanAngle / 2, fanAngle / 2);
          ctx.closePath();
        } else {
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
        }
      }

      function drawPowerOrb() {
        const x = ctr.x + Math.cos(state.orbAngle) * CONFIG.orb.radius;
        const y = ctr.y + Math.sin(state.orbAngle) * CONFIG.orb.radius;
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fillStyle = '#facc15';
        ctx.shadowBlur = 18;
        ctx.shadowColor = '#fde047';
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      function drawEnemies() {
        state.enemies.forEach((enemy) => {
          const def = CONFIG.enemies[enemy.type];
          ctx.fillStyle = enemy.type === 'melee' ? '#fb7185' : '#f472b6';
          ctx.beginPath();
          if (def.range <= 2) ctx.arc(enemy.x, enemy.y, 14, 0, Math.PI * 2);
          else if (def.range >= 9) ctx.rect(enemy.x - 14, enemy.y - 14, 28, 28);
          else {
            ctx.moveTo(enemy.x, enemy.y - 14);
            ctx.lineTo(enemy.x + 12, enemy.y + 14);
            ctx.lineTo(enemy.x - 12, enemy.y + 14);
            ctx.closePath();
          }
          ctx.fill();
          const ratio = enemy.maxHp ? enemy.hp / enemy.maxHp : enemy.hp / def.hp;
          ctx.fillStyle = '#0f172a';
          ctx.fillRect(enemy.x - 16, enemy.y - 24, 32, 4);
          ctx.fillStyle = '#f87171';
          ctx.fillRect(enemy.x - 16, enemy.y - 24, 32 * Math.max(0, Math.min(1, ratio)), 4);
        });
      }

      function drawAllies() {
        state.allies.forEach((ally) => {
          ctx.save();
          ctx.translate(ally.x, ally.y);
          ctx.fillStyle = ally.color || '#4ade80';
          drawShapePath(ally.shape || 'circle', ally.shape === 'rectangle' ? 8 : 10);
          ctx.fill();
          ctx.restore();
        });
      }

      function drawFlashes() {
        const now = performance.now();
        for (let i = state.flashes.length - 1; i >= 0; i -= 1) {
          const flash = state.flashes[i];
          const lifetime = flash.duration || 160;
          const age = now - flash.created;
          if (age > lifetime) {
            state.flashes.splice(i, 1);
            continue;
          }
          ctx.save();
          ctx.globalAlpha = Math.max(0, 1 - age / lifetime);
          if (flash.type === 'cone') {
            const radius = flash.radius || 60;
            const spread = ((flash.spread || 120) * Math.PI) / 180;
            const half = spread / 2;
            ctx.translate(flash.x, flash.y);
            ctx.rotate(flash.angle || 0);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, radius, -half, half);
            ctx.closePath();
            ctx.fillStyle = flash.color || 'rgba(59,130,246,0.5)';
            ctx.fill();
          } else if (flash.type === 'hit') {
            ctx.fillStyle = flash.color || 'rgba(248,113,113,0.4)';
            ctx.translate(flash.x, flash.y);
            ctx.fillRect(-flash.size, -flash.size, flash.size * 2, flash.size * 2);
          } else {
            ctx.strokeStyle = flash.color;
            ctx.lineWidth = flash.radius ? 3 : 2;
            ctx.beginPath();
            const radius = flash.radius ? flash.radius : 10 + (age / lifetime) * 12;
            ctx.arc(flash.x, flash.y, radius, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      function drawProjectiles() {
        const r = CONFIG.projectiles.size;
        state.projectiles.forEach((proj) => {
          ctx.beginPath();
          ctx.fillStyle = proj.color;
          ctx.arc(proj.x, proj.y, r, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawDamagePopups() {
        const now = performance.now();
        for (let i = state.damagePopups.length - 1; i >= 0; i -= 1) {
          const pop = state.damagePopups[i];
          const age = now - pop.created;
          if (age > pop.duration) {
            state.damagePopups.splice(i, 1);
            continue;
          }
          const progress = age / pop.duration;
          ctx.save();
          ctx.globalAlpha = 1 - progress;
          ctx.fillStyle = pop.color;
          ctx.font = `bold ${pop.size || 14}px Pretendard`;
          ctx.textAlign = 'center';
          ctx.fillText(Math.round(pop.amount), pop.x, pop.y - progress * 20);
          ctx.restore();
        }
      }

      function drawDraggingTower() {
        if (!state.dragging || !state.dragging.tower) return;
        ctx.save();
        ctx.translate(state.dragging.x, state.dragging.y);
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = towerColor(state.dragging.tower);
        ctx.fillRect(-20, -20, 40, 40);
        drawTowerVariantOverlay(state.dragging.tower);
        drawTowerLabels(state.dragging.tower);
        ctx.restore();
      }

      function drawMergeChoiceOverlay() {
        if (!state.mergeChoice) return;
        const choice = state.mergeChoice;
        ctx.save();
        ctx.fillStyle = 'rgba(2, 6, 23, 0.86)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f8fafc';
        ctx.font = 'bold 24px Pretendard';
        ctx.textAlign = 'center';
        const title =
          choice.type === 'heal' ? '3레벨 회복 타워를 선택하세요' : '3레벨 공격 타워를 선택하세요';
        ctx.fillText(title, ctr.x, ctr.y - 150);
        ctx.font = '15px Pretendard';
        ctx.fillText('카드를 클릭하면 게임이 다시 진행됩니다.', ctr.x, ctr.y - 120);
        const cardWidth = 220;
        const cardHeight = 220;
        const spacing = 30;
        const totalWidth = cardWidth * choice.cards.length + spacing * (choice.cards.length - 1);
        let startX = ctr.x - totalWidth / 2;
        const startY = ctr.y - cardHeight / 2;
        choice.cardBounds = [];
        choice.cards.forEach((card, idx) => {
          const x = startX + idx * (cardWidth + spacing);
          const y = startY;
          ctx.fillStyle = 'rgba(15,23,42,0.95)';
          ctx.strokeStyle = '#38bdf8';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, cardWidth, cardHeight);
          ctx.strokeRect(x, y, cardWidth, cardHeight);
          ctx.fillStyle = '#f8fafc';
          ctx.font = '18px Pretendard';
          ctx.textAlign = 'center';
          ctx.fillText(card.title, x + cardWidth / 2, y + 30);
          const shapeColor = choice.type === 'heal' ? '#facc15' : '#38bdf8';
          drawChoiceShape(card.shape, x + cardWidth / 2, y + 95, shapeColor);
          ctx.fillStyle = '#cbd5f5';
          ctx.font = '13px Pretendard';
          ctx.textAlign = 'left';
          const lines = card.desc.split('\n');
          lines.forEach((line, lineIdx) => {
            ctx.fillText(line, x + 16, y + 140 + lineIdx * 18);
          });
          choice.cardBounds.push({ x, y, width: cardWidth, height: cardHeight, option: card });
        });
        ctx.restore();
      }

      function drawChoiceShape(shape, cx, cy, color = '#38bdf8') {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.beginPath();
        drawShapePath(shape, 32);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.restore();
      }

      function drawOverlay() {
        ctx.fillStyle = 'rgba(2, 6, 23, 0.85)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f8fafc';
        ctx.font = 'bold 30px Pretendard';
        ctx.textAlign = 'center';
        ctx.fillText(state.result, ctr.x, ctr.y - 8);
        ctx.font = '18px Pretendard';
        ctx.fillText(`기록: ${Math.floor(state.elapsed / 1000)}초`, ctr.x, ctr.y + 20);
      }

      canvas.addEventListener('pointerdown', handlePointerDown);
      window.addEventListener('pointermove', handlePointerMove);
      window.addEventListener('pointerup', handlePointerUp);
      window.addEventListener('pointercancel', handlePointerUp);

      UI.buyBtn.addEventListener('click', () => {
        if (!state.running || state.gameOver || state.gold < CONFIG.runtime.towerCost) return;
        const emptySlots = state.slots.filter((slot) => !slot.tower);
        if (!emptySlots.length) return;
        state.gold -= CONFIG.runtime.towerCost;
        const slot = randomOf(emptySlots);
        const pool = Math.random() < 0.5 ? CONFIG.towers.offense : [...CONFIG.towers.summon, CONFIG.towers.heal];
        slot.tower = createTower(randomOf(pool), slot);
        registerTower(slot.tower);
        updateHUD();
      });

     UI.emergencyBtn.addEventListener('click', () => {
       if (!state.running || state.gameOver || state.gold < CONFIG.emergency.cost) return;
       state.gold -= CONFIG.emergency.cost;
       state.orbBoostLoops += CONFIG.emergency.loops;
       updateHUD();
     });

     UI.cheatBtn.addEventListener('click', () => {
        if (!state.running || state.gameOver) return;
        state.gold += 200;
        updateHUD();
      });

      UI.startBtn.addEventListener('click', () => {
        resetGame();
        state.running = true;
        UI.startBtn.textContent = '다시 시작';
      });

      async function boot() {
        await loadExternalConfig();
        resetGame();
        state.running = true;
        UI.startBtn.textContent = '다시 시작';
        requestAnimationFrame(gameLoop);
      }

      boot();
    </script>
